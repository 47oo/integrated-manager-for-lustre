# -*- coding: utf-8 -*-
#
# INTEL CONFIDENTIAL
#
# Copyright 2013-2015 Intel Corporation All Rights Reserved.
#
# The source code contained or described herein and all documents related
# to the source code ("Material") are owned by Intel Corporation or its
# suppliers or licensors. Title to the Material remains with Intel Corporation
# or its suppliers and licensors. The Material contains trade secrets and
# proprietary and confidential information of Intel or its suppliers and
# licensors. The Material is protected by worldwide copyright and trade secret
# laws and treaty provisions. No part of the Material may be used, copied,
# reproduced, modified, published, uploaded, posted, transmitted, distributed,
# or disclosed in any way without Intel's prior express written permission.
#
# No license under any patent, copyright, trade secret or other intellectual
# property right is granted to or conferred upon you by disclosure or delivery
# of the Materials, either expressly, by implication, inducement, estoppel or
# otherwise. Any license under such intellectual property rights must be
# express and approved by Intel in writing.

import json
import logging

from django.db import models

from django.core.exceptions import ObjectDoesNotExist

from chroma_core.models import AlertState
from chroma_core.models import AlertEvent
from chroma_core.models import DeletableStatefulObject
from chroma_core.models import StateChangeJob
from chroma_core.models import NullStateChangeJob
from chroma_core.models import Nid
from chroma_core.models import Job, StateLock
from chroma_core.models import NetworkInterface
from chroma_core.lib.job import DependOn, DependAll, Step
from chroma_help.help import help_text


class LNetConfiguration(DeletableStatefulObject):
    states = ['unconfigured', 'lnet_unloaded', 'lnet_down', 'lnet_up']
    initial_state = 'unconfigured'

    host = models.OneToOneField('ManagedHost', related_name='lnetconfiguration')

    def get_nids(self):
        return [n.nid_string for n in self.nid_set.all()]

    def __str__(self):
        return "%s LNet configuration" % (self.host)

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def get_label(self):
        return "lnet configuration"

    def set_state(self, state, intentional = False):
        """
        :param intentional: set to true to silence any alerts generated by this transition
        """
        super(LNetConfiguration, self).set_state(state, intentional)
        if intentional:
            LNetOfflineAlert.notify_warning(self, self.state != 'lnet_up')
        else:
            LNetOfflineAlert.notify(self, self.state != 'lnet_up')

    reverse_deps = {
        'ManagedHost': lambda mh: LNetConfiguration.objects.filter(id = mh.lnetconfiguration.id),
    }


class LNetOfflineAlert(AlertState):
    # LNET being offline is never solely responsible for a filesystem
    # being unavailable: if a target is offline we will get a separate
    # ERROR alert for that.  LNET being offline may indicate a configuration
    # fault, but equally could just indicate that the host hasn't booted up that far yet.
    default_severity = logging.INFO

    def message(self):
        return "LNet offline on server %s" % self.alert_item

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def end_event(self):
        return AlertEvent(
            message_str = "LNet started on server '%s'" % self.alert_item.host,
            host = self.alert_item.host,
            alert = self,
            severity = logging.INFO)


class LNetNidsChangedAlert(AlertState):
    # This is WARNING because targets on this host will not work
    # correctly until it is addressed, but the filesystem may still
    # be available if a failover server is not in this condition.
    default_severity = logging.WARNING

    def message(self):
        msg = "NIDs changed on server %s - see manual for details."
        return msg % self.alert_item

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def end_event(self):
        return AlertEvent(
            message_str = "LNet NIDs updated for server %s" % self.alert_item,
            host = self.alert_item,
            alert = self,
            severity = logging.INFO)


class ConfigureLNetStep(Step):
    idempotent = True

    # FIXME: using database=True to do the alerting update inside .set_state but
    # should do it in a completion
    database = True

    def run(self, kwargs):
        host = kwargs['host']
        nid_updates = kwargs['config_changes']['nid_updates']
        nid_deletes = kwargs['config_changes']['nid_deletes']

        modprobe_entries = []
        nid_tuples = []

        network_interfaces = NetworkInterface.objects.filter(host=host)
        lnet_configuration = LNetConfiguration.objects.get(host=host)

        for network_interface in network_interfaces:
            # See if we have deleted the nid for this network interface or
            # see if we have a new configuration for this if we do then it
            # will replace the current configuration.
            #
            # The int will have become a string - we should use a PickledObjectField really.
            if str(network_interface.id) in nid_deletes:
                nid = None
            elif str(network_interface.id) in nid_updates:
                nid = Nid(network_interface = network_interface,
                          lnet_configuration = lnet_configuration,
                          lnd_network = nid_updates[str(network_interface.id)]['lnd_network'],
                          lnd_type = nid_updates[str(network_interface.id)]['lnd_type'])
            else:
                try:
                    nid = Nid.objects.get(network_interface = network_interface)
                except ObjectDoesNotExist:
                    nid = None
                    pass

            if nid is not None:
                modprobe_entries.append(nid.modprobe_entry)
                nid_tuples.append(nid.to_tuple)

        self.invoke_agent_expect_result(host,
                                        "configure_lnet",
                                        {'lnet_configuration': {'state': lnet_configuration.state,
                                                                'modprobe_entries': modprobe_entries,
                                                                'network_interfaces': nid_tuples}})


class ConfigureLNetJob(Job):
    lnet_configuration = models.ForeignKey(LNetConfiguration)
    config_changes = models.CharField(max_length = 4096, help_text = "A json string describing the configuration changes")
    requires_confirmation = False
    state_verb = "Configure LNet"

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def create_locks(self):
        return [StateLock(
            job = self,
            locked_item = self.lnet_configuration,
            write = True
        )]

    @classmethod
    def long_description(cls, stateful_object):
        return help_text['configure_lnet']

    def description(self):
        return "Configure LNet for %s" % self.lnet_configuration.host

    def get_steps(self):
        # The get_deps means the lnet is always placed into the unloaded state in preparation for the change in
        # configure the next two steps cause lnet to return to the state it was in
        steps = [(ConfigureLNetStep, {'host': self.lnet_configuration.host, 'config_changes': json.loads(self.config_changes)})]

        if (self.lnet_configuration.state != 'lnet_unloaded'):
            steps.append((LoadLNetStep, {'host': self.lnet_configuration.host}))

        if (self.lnet_configuration.state == 'lnet_up'):
            steps.append((StartLNetStep, {'host': self.lnet_configuration.host}))

        steps.append((GetLNetStateStep, {'host': self.lnet_configuration.host}))

        return steps

    def get_deps(self):
        return DependOn(self.lnet_configuration, 'lnet_unloaded')


class UnconfigureLNetStep(Step):
    idempotent = True

    def run(self, kwargs):
        host = kwargs['host']
        if not host.immutable_state:
            self.invoke_agent_expect_result(host, "unconfigure_lnet")


class UnconfigureLNetJob(NullStateChangeJob):
    target_object = models.ForeignKey(LNetConfiguration)
    state_transition = (LNetConfiguration, 'lnet_unloaded', 'unconfigured')
    _long_description = help_text['change_state_of_lnet_to_unconfigured']

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def description(self):
        return "Change lnet state of %s to unconfigured " % self.target_object.host

    def get_steps(self):
        return [(UnconfigureLNetStep, {'host': self.target_object.host})]


class EnableLNetJob(NullStateChangeJob):
    target_object = models.ForeignKey(LNetConfiguration)
    state_transition = (LNetConfiguration, 'unconfigured', 'lnet_unloaded')
    _long_description = help_text['enable_lnet']

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def description(self):
        return "Enable LNet on %s" % self.target_object.host

    def get_deps(self):
        '''
        Before LNet operations are possible some dependencies are need, basically the host must have had its packages installed.
        Maybe we need a packages object, but this routine at least keeps the detail in one place.

        Or maybe we need an unacceptable_states lists.
        :return:
        '''
        if self.target_object.host.state in ['unconfigured', 'undeployed']:
            return DependOn(self.target_object.host, 'packages_installed')
        else:
            return DependAll()


class LoadLNetStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "load_lnet")


class LoadLNetJob(StateChangeJob):
    state_transition = (LNetConfiguration, 'lnet_unloaded', 'lnet_down')
    stateful_object = 'lnet_configuration'
    lnet_configuration = models.ForeignKey(LNetConfiguration)
    state_verb = 'Load LNet'

    display_group = Job.JOB_GROUPS.COMMON
    display_order = 30

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["load_lnet"]

    def description(self):
        return "Load LNet module on %s" % self.lnet_configuration.host

    def get_steps(self):
        return [(LoadLNetStep, {'host': self.lnet_configuration.host}),
                (GetLNetStateStep, {'host': self.lnet_configuration.host})]


class StartLNetStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "start_lnet")


class StartLNetJob(StateChangeJob):
    state_transition = (LNetConfiguration, 'lnet_down', 'lnet_up')
    stateful_object = 'lnet_configuration'
    lnet_configuration = models.ForeignKey(LNetConfiguration)
    state_verb = 'Start LNet'

    display_group = Job.JOB_GROUPS.COMMON
    display_order = 40

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["start_lnet"]

    def description(self):
        return "Start LNet on %s" % self.lnet_configuration.host

    def get_steps(self):
        return [(StartLNetStep, {'host': self.lnet_configuration.host}),
                (GetLNetStateStep, {'host': self.lnet_configuration.host})]


class StopLNetStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "stop_lnet")


class StopLNetJob(StateChangeJob):
    state_transition = (LNetConfiguration, 'lnet_up', 'lnet_down')
    stateful_object = 'lnet_configuration'
    lnet_configuration = models.ForeignKey(LNetConfiguration)
    state_verb = 'Stop LNet'

    display_group = Job.JOB_GROUPS.RARE
    display_order = 100

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["stop_lnet"]

    def description(self):
        return "Stop LNet on %s" % self.lnet_configuration.host

    def get_steps(self):
        return [(StopLNetStep, {'host': self.lnet_configuration.host}),
                (GetLNetStateStep, {'host': self.lnet_configuration.host})]


class UnloadLNetStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "unload_lnet")


class UnloadLNetJob(StateChangeJob):
    state_transition = (LNetConfiguration, 'lnet_down', 'lnet_unloaded')
    stateful_object = 'lnet_configuration'
    lnet_configuration = models.ForeignKey(LNetConfiguration)
    state_verb = 'Unload LNet'

    display_group = Job.JOB_GROUPS.RARE
    display_order = 110

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["unload_lnet"]

    def description(self):
        return "Unload LNet module on %s" % self.lnet_configuration.host

    def get_steps(self):
        return [(UnloadLNetStep, {'host': self.lnet_configuration.host}),
                (GetLNetStateStep, {'host': self.lnet_configuration.host})]


class GetLNetStateStep(Step):
    idempotent = True

    # Require database to talk to plugin_manager
    database = True

    def run(self, kwargs):
        from chroma_core.services.plugin_runner.agent_daemon_interface import AgentDaemonRpcInterface
        from chroma_core.services.job_scheduler.agent_rpc import AgentException

        host = kwargs['host']

        try:
            network_data = self.invoke_agent(host, "device_plugin", {'plugin': 'linux_network'})['linux_network']
            AgentDaemonRpcInterface().update_host_resources(host.id, {'linux_network': network_data})
        except TypeError:
            self.log("Data received from old client. Host %s state cannot be updated until agent is updated" % host)
        except AgentException as e:
            self.log("No data for plugin linux_network from host %s due to exception %s" % (host, e))


class GetLNetStateJob(Job):
    """ This is an unused historical class, we can't delete it because old commands may have referenced it
    so it will just sit here for ever more. Maybe someone clever can turn it into a useful class and use it
    for something else.
    """
    host = models.ForeignKey('ManagedHost')

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text['lnet_state']

    def description(self):
        return "Get LNet state for %s" % self.host
