# -*- coding: utf-8 -*-
#
# INTEL CONFIDENTIAL
#
# Copyright 2013-2015 Intel Corporation All Rights Reserved.
#
# The source code contained or described herein and all documents related
# to the source code ("Material") are owned by Intel Corporation or its
# suppliers or licensors. Title to the Material remains with Intel Corporation
# or its suppliers and licensors. The Material contains trade secrets and
# proprietary and confidential information of Intel or its suppliers and
# licensors. The Material is protected by worldwide copyright and trade secret
# laws and treaty provisions. No part of the Material may be used, copied,
# reproduced, modified, published, uploaded, posted, transmitted, distributed,
# or disclosed in any way without Intel's prior express written permission.
#
# No license under any patent, copyright, trade secret or other intellectual
# property right is granted to or conferred upon you by disclosure or delivery
# of the Materials, either expressly, by implication, inducement, estoppel or
# otherwise. Any license under such intellectual property rights must be
# express and approved by Intel in writing.

import logging

from django.utils.timezone import now
from django.db import models

from chroma_core.models import AlertState
from chroma_core.models import AlertEvent
from chroma_core.models import DeletableStatefulObject
from chroma_core.models import StateChangeJob
from chroma_core.models import NetworkInterface
from chroma_core.models.jobs import Job, StateLock
from chroma_core.lib.job import DependOn, DependAll, Step
from chroma_help.help import help_text
from chroma_core.services.job_scheduler import job_scheduler_notify


class CorosyncConfiguration(DeletableStatefulObject):
    states = ['unconfigured', 'stopped', 'started']
    initial_state = 'unconfigured'

    host = models.OneToOneField('ManagedHost', related_name='_corosync_configuration')

    mcast_port = models.IntegerField(null=True)

    # Up from the point of view of a peer in the corosync cluster for this node
    corosync_reported_up = models.BooleanField(default=False,
                                               help_text="True if corosync on a node in this node's "
                                                         "cluster reports that this node is online")

    def __str__(self):
        return "%s Corosync configuration" % self.host

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def get_label(self):
        return "corosync configuration"

    def set_state(self, state, intentional = False):
        """
        :param intentional: set to true to silence any alerts generated by this transition
        """
        super(CorosyncConfiguration, self).set_state(state, intentional)
        if intentional:
            CorosyncStoppedAlert.notify_warning(self, self.state != 'started')
        else:
            CorosyncStoppedAlert.notify(self, self.state != 'started')

    reverse_deps = {
        'ManagedHost': lambda mh: CorosyncConfiguration.objects.filter(host_id = mh.id),
    }

    @property
    def network_interfaces(self):
        return [network_interface for network_interface in NetworkInterface.objects.filter(corosync_configuration = self)]

    @network_interfaces.setter
    def network_interfaces(self, interface_names):
        host_interfaces = NetworkInterface.objects.filter(host = self.host)

        for interface in host_interfaces:                               # Mark all interface_names as not corosync.
            if interface.corosync_configuration == self:
                interface.corosync_configuration = None

        for interface_name in interface_names:
            try:                                                        # Mark interface_names as corosync if it is existing.
                network_interface = next(network_interface for network_interface in host_interfaces if network_interface.name == interface_name)
                network_interface.corosync_configuration = self
            except StopIteration:
                pass

        for interface in host_interfaces:
            interface.save()


class CorosyncUnknownPeersAlert(AlertState):
    """Alert should be raised when a Host has an unknown Peer.

    When a corosync agent reports a peer that we do not know, we should raise an alert.
    """

    # This is worse than INFO because it *could* indicate that
    # networking is misconfigured..
    default_severity = logging.WARNING

    def message(self):
        return "Host has unknown peer %s" % self.alert_item.host

    class Meta:
        app_label = 'chroma_core'

    @property
    def affected_objects(self):
        """
        :return: A list of objects that are affected by this alert
        """
        return [self.alert_item.host]


class CorosyncToManyPeersAlert(AlertState):
    """Alert should be raised when a Host has an unknown Peer.

    When a corosync agent reports a peer that we do not know, we should raise an alert.
    """

    # This is worse than INFO because it *could* indicate that
    # networking is misconfigured..
    default_severity = logging.WARNING

    def message(self):
        return "Host %s has to many failover pears" % self.alert_item.host

    class Meta:
        app_label = 'chroma_core'

    @property
    def affected_objects(self):
        """
        :return: A list of objects that are affected by this alert
        """
        return [self.alert_item.host]


class CorosyncNoPeersAlert(AlertState):
    """Alert should be raised when a Host has an unknown Peer.

    When a corosync agent reports a peer that we do not know, we should raise an alert.
    """

    # This is worse than INFO because it *could* indicate that
    # networking is misconfigured..
    default_severity = logging.WARNING

    def message(self):
        return "Host %s no failover peers" % self.alert_item.host

    class Meta:
        app_label = 'chroma_core'

    @property
    def affected_objects(self):
        """
        :return: A list of objects that are affected by this alert
        """
        return [self.alert_item.host]


class CorosyncStoppedAlert(AlertState):
    # Corosync being down is never solely responsible for a filesystem
    # being unavailable: if a target is offline we will get a separate
    # ERROR alert for that.  Corosync being offline may indicate a configuration
    # fault, but equally could just indicate that the host hasn't booted up that far yet.
    default_severity = logging.INFO

    def message(self):
        return "Corosync stopped on server %s" % self.alert_item.host

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def end_event(self):
        return AlertEvent(
            message_str = "Corosync started on server '%s'" % self.alert_item.host,
            host = self.alert_item.host,
            alert = self,
            severity = logging.WARNING)

    @property
    def affected_objects(self):
        """
        :return: A list of objects that are affected by this alert
        """
        return [self.alert_item.host]


class AutoConfigureCorosyncStep(Step):
    idempotent = True

    def run(self, kwargs):
        corosync_configuration = kwargs['corosync_configuration']

        config = self.invoke_agent_expect_result(corosync_configuration.host, "get_corosync_autoconfig")

        ring0_name, ring0_config = next((interface, config) for interface, config in config['interfaces'].items() if config['dedicated'] == False)
        ring1_name, ring1_config = next((interface, config) for interface, config in config['interfaces'].items() if config['dedicated'] == True)

        self.invoke_agent_expect_result(corosync_configuration.host,
                                        "configure_corosync",
                                        {'ring0_name': ring0_name,
                                         'ring1_name': ring1_name,
                                         'ring1_ipaddr': ring1_config['ipaddr'],
                                         'ring1_prefix': ring1_config['prefix'],
                                         'mcast_port': config['mcast_port']})

        job_scheduler_notify.notify(corosync_configuration,
                                    now(),
                                    {'mcast_port': config['mcast_port'],
                                     'network_interfaces': [ring0_name, ring1_name]})


class AutoConfigureCorosyncJob(StateChangeJob):
    state_transition = (CorosyncConfiguration, 'unconfigured', 'stopped')
    stateful_object = 'corosync_configuration'
    corosync_configuration = models.ForeignKey(CorosyncConfiguration)
    state_verb = 'Configure Corosync'

    display_group = Job.JOB_GROUPS.COMMON
    display_order = 30

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["configure_corosync"]

    def description(self):
        return help_text['configure_corosync_on'] % self.corosync_configuration.host

    def get_steps(self):
        return [(AutoConfigureCorosyncStep, {'corosync_configuration': self.corosync_configuration})]

    def get_deps(self):
        '''
        Before Corosync operations are possible some dependencies are need, basically the host must have had its packages installed.
        Maybe we need a packages object, but this routine at least keeps the detail in one place.

        Or maybe we need an unacceptable_states lists.
        :return:
        '''
        if self.corosync_configuration.host.state in ['unconfigured', 'undeployed']:
            return DependOn(self.corosync_configuration.host, 'packages_installed')
        else:
            return DependAll()


class UnconfigureCorosyncStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "unconfigure_corosync")


class UnconfigureCorosyncJob(StateChangeJob):
    state_transition = (CorosyncConfiguration, 'stopped', 'unconfigured')
    stateful_object = 'corosync_configuration'
    corosync_configuration = models.ForeignKey(CorosyncConfiguration)
    state_verb = 'Unconfigure Corosync'

    display_group = Job.JOB_GROUPS.COMMON
    display_order = 30

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["unconfigure_corosync"]

    def description(self):
        return "Unconfigure Corosync on %s" % self.corosync_configuration.host

    def get_steps(self):
        return [(UnconfigureCorosyncStep, {'host': self.corosync_configuration.host})]


class StartCorosyncStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "start_corosync")


class StartCorosyncJob(StateChangeJob):
    state_transition = (CorosyncConfiguration, 'stopped', 'started')
    stateful_object = 'corosync_configuration'
    corosync_configuration = models.ForeignKey(CorosyncConfiguration)
    state_verb = 'Start Corosync'

    display_group = Job.JOB_GROUPS.COMMON
    display_order = 30

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["start_corosync"]

    def description(self):
        return "Start Corosync on %s" % self.corosync_configuration.host

    def get_steps(self):
        return [(StartCorosyncStep, {'host': self.corosync_configuration.host})]


class StopCorosyncStep(Step):
    idempotent = True

    def run(self, kwargs):
        self.invoke_agent_expect_result(kwargs['host'], "stop_corosync")


class StopCorosyncJob(StateChangeJob):
    state_transition = (CorosyncConfiguration, 'started', 'stopped')
    stateful_object = 'corosync_configuration'
    corosync_configuration = models.ForeignKey(CorosyncConfiguration)
    state_verb = 'Stop Corosync'

    display_group = Job.JOB_GROUPS.RARE
    display_order = 100

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text["stop_corosync"]

    def description(self):
        return "Stop Corosync on %s" % self.corosync_configuration.host

    def get_steps(self):
        return [(StopCorosyncStep, {'host': self.corosync_configuration.host})]

    def get_deps(self):
        return DependOn(self.corosync_configuration.host.pacemaker_configuration, 'stopped', unacceptable_states=['started'])


class GetCorosyncStateStep(Step):
    idempotent = True

    # FIXME: using database=True to do the alerting update inside .set_state but
    # should do it in a completion
    database = True

    def run(self, kwargs):
        from chroma_core.services.job_scheduler.agent_rpc import AgentException

        host = kwargs['host']

        try:
            lnet_data = self.invoke_agent(host, "device_plugin", {'plugin': 'linux_network'})['linux_network']['lnet']
            host.set_state(lnet_data['state'])
            host.save()
        except TypeError:
            self.log("Data received from old client. Host %s state cannot be updated until agent is updated" % host)
        except AgentException as e:
            self.log("No data for plugin linux_network from host %s due to exception %s" % (host, e))


class GetCorosyncStateJob(Job):
    corosync_configuration = models.ForeignKey(CorosyncConfiguration)
    requires_confirmation = False
    verb = "Get Corosync state"

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    def create_locks(self):
        return [StateLock(
            job = self,
            locked_item = self.corosync_configuration,
            write = True
        )]

    @classmethod
    def get_args(cls, corosync_configuration):
        return {'host': corosync_configuration.host}

    @classmethod
    def long_description(cls, stateful_object):
        return help_text['corosync_state']

    def description(self):
        return "Get Corosync state for %s" % self.corosync_configuration.host

    def get_steps(self):
        return [(GetCorosyncStateStep, {'host': self.corosync_configuration.host})]


class ConfigureCorosyncStep(Step):
    idempotent = True
    database = True

    def run(self, kwargs):
        corosync_configuration = kwargs['corosync_configuration']

        self.invoke_agent_expect_result(corosync_configuration.host,
                                        "configure_corosync",
                                        {'ring0_name': kwargs['ring0_name'],
                                         'ring1_name': kwargs['ring1_name'],
                                         'mcast_port': kwargs['mcast_port']})

        job_scheduler_notify.notify(corosync_configuration,
                                    now(),
                                    {'mcast_port': kwargs['mcast_port'],
                                     'network_interfaces': [kwargs['ring0_name'], kwargs['ring1_name']]})


class ConfigureCorosyncJob(Job):
    corosync_configuration = models.ForeignKey(CorosyncConfiguration)
    network_interface_0 = models.ForeignKey(NetworkInterface, related_name='interface_0')
    network_interface_1 = models.ForeignKey(NetworkInterface, related_name='interface_1')
    mcast_port = models.IntegerField(null = True)

    class Meta:
        app_label = 'chroma_core'
        ordering = ['id']

    @classmethod
    def long_description(cls, stateful_object):
        return help_text['configure_corosync_on'] % stateful_object.host.fqdn

    def description(self):
        return help_text['configure_corosync']

    def get_steps(self):
        steps = [(ConfigureCorosyncStep, {'corosync_configuration': self.corosync_configuration,
                                          'ring0_name': self.network_interface_0.name,
                                          'ring1_name': self.network_interface_1.name,
                                          'mcast_port': self.mcast_port})]

        return steps

    def get_deps(self):
        return DependOn(self.corosync_configuration, 'stopped')
