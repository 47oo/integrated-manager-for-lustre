import inspect
import logging
import os
import paramiko
import time

from django.utils.unittest import TestCase

from testconfig import config

from tests.integration.core.constants import TEST_TIMEOUT

logger = logging.getLogger('test')
logger.setLevel(logging.DEBUG)
handler = logging.FileHandler(os.path.join(config.get('log_dir', '/var/log/'), 'chroma_test.log'))
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

# paramiko.transport logger spams nose log collection so we're quieting it down
paramiko_logger = logging.getLogger('paramiko.transport')
paramiko_logger.setLevel(logging.WARN)


class RemoteCommandResult(object):
    """
    Conveniently stores the various output of a remotely executed command.
    """

    def __init__(self, exit_status, stdout, stderr, *args, **kwargs):
        super(RemoteCommandResult, self).__init__(*args, **kwargs)
        self.exit_status = exit_status
        self.stdout = stdout
        self.stderr = stderr


class UtilityTestCase(TestCase):
    """
    Adds a few non-api specific utility functions for the integration tests.
    """

    def setUp(self):
        self.maxDiff = None                                     # By default show the complete diff on errors.

    def remote_command(self, server, command, expected_return_code=0, timeout=TEST_TIMEOUT):
        """
        Executes a command on a remote server over ssh.

        Sends a command over ssh to a remote machine and returns the stdout,
        stderr, and exit status. It will verify that the exit status of the
        command matches expected_return_code unless expected_return_code=None.

        FIXME: Extreme redundancy with _ssh_address in RealRemoteOperations.
        """
        logger.debug("remote_command[%s]: %s" % (server, command))
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(server, **{'username': 'root'})
        transport = ssh.get_transport()
        transport.set_keepalive(20)
        channel = transport.open_session()
        channel.settimeout(timeout)
        channel.exec_command(command)
        exit_status = channel.recv_exit_status()
        stdout = channel.makefile('rb').read()
        stderr = channel.makefile_stderr('rb').read()
        if expected_return_code is not None:
            self.assertEqual(exit_status, expected_return_code, stderr)
        return RemoteCommandResult(exit_status, stdout, stderr)

    def wait_until_true(self, lambda_expression, timeout=TEST_TIMEOUT):
        """
        Evaluates lambda_expression once/1s until True or hits timeout.
        """
        running_time = 0
        lambda_result = None
        while not lambda_result and running_time < timeout:
            lambda_result = lambda_expression()
            logger.debug("%s evaluated to %s" % (inspect.getsource(lambda_expression), lambda_result))
            time.sleep(1)
            running_time += 1
        self.assertLess(running_time, timeout, "Timed out waiting for %s." % inspect.getsource(lambda_expression))

    def wait_for_items_length(self, fetch_items, length, timeout=TEST_TIMEOUT):
        """
        Assert length of items list generated by func over time or till timeout.
        """
        items = fetch_items()
        while timeout and length != len(items):
            logger.debug("%s evaluated to %s expecting list size of %s items" % (inspect.getsource(fetch_items), items, length))
            time.sleep(1)
            timeout -= 1
            items = fetch_items()
        self.assertNotEqual(0, timeout, "Timed out waiting for %s." % inspect.getsource(fetch_items))

    def wait_for_assert(self, lambda_expression, timeout=TEST_TIMEOUT):
        """
        Evaluates lambda_expression once/1s until no AssertionError or hits
        timeout.
        """
        running_time = 0
        while running_time < timeout:
            try:
                lambda_expression()
            except AssertionError, e:
                logger.debug("%s tripped assertion: %s" % (inspect.getsource(lambda_expression), e))
            else:
                break
            time.sleep(1)
            running_time += 1
        self.assertLess(running_time, timeout, "Timed out waiting for %s." % inspect.getsource(lambda_expression))

    def get_host_config(self, nodename):
        """
        Get the entry for a lustre server from the cluster config.
        """
        for host in config['lustre_servers']:
            if host['nodename'] == nodename:
                return host
