#!/usr/bin/env python

import glob
import logging
import tempfile
import shutil
import subprocess
import os
import tarfile
import sys
import rpm
import json
import errno
import select
import base64
from urlparse import urlparse, urlunparse
import yum
import urllib2
import time


PRODUCT_NAME = "Intel(R) Manager for Lustre* software"
ARCHIVE_SUFFIX = ".tar.gz"

# Although we will install everything, use this package as the 'it' when asking
# what version of 'it' is installed.
MAIN_PACKAGE = "chroma-manager"

BUNDLE_ROOT = "/var/lib/chroma/repo"
BUNDLE_BACKUP = "/var/lib/chroma/repo.previous"
LOG_DIR = "/var/log/chroma"
LOG_FILE = os.path.join(LOG_DIR, "install.log")


def _display_eula():
    try:
        p = subprocess.Popen(["less", "-F", "-X", "-e", "-k",
                               "lesskey.out", "EULA.txt"])
        p.wait()
    except KeyboardInterrupt:
        print "\n\nYou must read all of the EULA and agree to the terms in order to install the software"
        # less can leave the terminal in a weird state
        subprocess.call(["stty", "sane"])
        sys.exit(0)

    answer = ""
    while answer not in ["yes", "no"]:
       answer = raw_input("Do you agree to the license terms?  (yes/no) ")
       log.debug("EULA response: %s" % answer)

    if answer.lower() != "yes":
        log.error("EULA declined -- exiting without installation")
        sys.exit(0)


def _mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise e
        elif e.errno == errno.EEXIST and not os.path.isdir(path):
            raise RuntimeError("%s exists but is not a directory" % path)


def spinner(p):
    chars = '/-\|'
    n = 0
    prev_time = time.time()
    line = p.stdout.readline()
    while line:
        char = chars[n % 4]
        this_time = time.time()
        log.debug("%f: %s" % (this_time - prev_time, line.rstrip()))
        sys.stdout.write(char)
        sys.stdout.flush()
        sys.stdout.write('\r')
        line = p.stdout.readline()
        n+=1
        prev_time = this_time
    p.wait()
    print


def _run(args, passthrough=False, drain_stdin=False):
    """
    :param passthrough: If true, pass stdin+stdout through to the user rather
    than capturing them.
    """
    log.debug("Running %s" % args)
    if drain_stdin:
        while len(select.select([sys.stdin.fileno()], [], [], 0.0)[0])>0:
            os.read(sys.stdin.fileno(), 4096)
    if passthrough:
        p = subprocess.Popen(args)
    else:
        p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    rc = p.returncode
    log.debug("rc=%s" % rc)
    log.debug("stdout=%s" % stdout)
    log.debug("stderr=%s" % stderr)
    if rc != 0:
        log.error("An error occurred running `{command}`, see {LOG_FILE} for details".format(
            command=args[0],
            LOG_FILE=LOG_FILE
        ))
        sys.exit(-1)

    return rc, stdout, stderr


def _check_root():
    if os.geteuid() != 0:
        log.error("This script must be run as root")
        sys.exit(-1)


def _setup_logging():
    _mkdir_p(LOG_DIR)

    log = logging.getLogger('install')
    log.setLevel(logging.DEBUG)

    screen_output = logging.StreamHandler()
    screen_output.setLevel(logging.INFO)
    screen_output.setFormatter(logging.Formatter('\033[1m%(message)s\033[0m'))
    log.addHandler(screen_output)
    file_output = logging.FileHandler(LOG_FILE)
    file_output.setLevel(logging.DEBUG)
    file_output.setFormatter(logging.Formatter('[%(asctime)s] %(levelname)s %(message)s', '%d/%b/%Y:%H:%M:%S'))
    log.addHandler(file_output)

    return log


def _unpack_repo(tarball_path, destination):
    log.debug("Extracting %s to %s" % (tarball_path, destination))
    _mkdir_p(destination)
    archive = tarfile.open(tarball_path, "r:gz")
    archive.extractall(destination)


def _print_version(version = None, release = None):
    if not version:
        version, release = _get_version()

    if version:
        log.info("{MAIN_PACKAGE} {version}-{release} is currently installed".format(
                 MAIN_PACKAGE=MAIN_PACKAGE,
                 version=version,
                 release=release
        ))

def _get_version():
    ts = rpm.TransactionSet()
    headers = ts.dbMatch('name', MAIN_PACKAGE)
    if not headers:
        version = release = None
    else:
        header = list(headers)[0]
        version=header['version']
        release=header['release']

    return version, release

def _new_bundles():
    bundles = {}
    log.debug("Bundles in {action} package:".format(action = "upgrade" \
                                                        if upgrade \
                                                        else "installation"))
    bundle_files = glob.glob("*-bundle%s" % ARCHIVE_SUFFIX)
    for bundle_file in bundle_files:
        archive = tarfile.open(bundle_file, "r:gz")
        try:
            meta_file = archive.extractfile('./meta')
        except KeyError:
            log.error("Malformed bundle file %s:" % bundle_file)
            log.error(archive.list())
            sys.exit(-1)
        meta = json.load(meta_file)
        log.debug("{name}-{version}: {description}".format(
            name=meta['name'],
            version=meta['version'],
            description=meta['description']
        ))
        meta['filename'] = bundle_file
        bundles[meta['name']] = meta

    return bundles


def _new_profiles():
    profiles = []
    log.debug("Profiles in {action} package:".format(action = "upgrade" \
                                                         if upgrade \
                                                         else "installation"))
    profile_files = glob.glob("*.profile")
    for profile_file in profile_files:
        profile = json.load(open(profile_file))
        log.debug("{name}: {description}".format(
            name=profile['ui_name'],
            description=profile['ui_description']
        ))
        profiles.append(profile_file)

    return profiles


def _old_bundles():
    bundles = {}
    log.debug("Bundles currently installed:")
    for bundle_meta_path in glob.glob(os.path.join(BUNDLE_ROOT, "*/meta")):
        meta = json.load(open(bundle_meta_path))
        log.debug("{name}-{version}: {description}".format(
            name=meta['name'],
            version=meta['version'],
            description=meta['description']
        ))
        bundles[meta['name']] = meta

    return bundles

def _create_manager_repo():
    manager_repo_dir = tempfile.mkdtemp()
    log.debug("Temporary yum repo at %s" % manager_repo_dir)
    log.info("Unpacking installation package")
    manager_tarball = glob.glob('*-manager-*%s' % ARCHIVE_SUFFIX)[0]
    _unpack_repo(manager_tarball, manager_repo_dir)

    manager_repo_file = tempfile.NamedTemporaryFile(dir="/etc/yum.repos.d/", suffix=".repo", delete=False)
    log.debug("Temporary yum config at %s" % manager_repo_file.name)
    repo_text = """
# Temporary file
# Created by Intel(R) Manager for Lustre* software upgrade script
[chroma-manager]
name=chroma-manager
baseurl=file://{manager_repo_dir}
gpgcheck=0
enable=0
    """.format(manager_repo_dir=manager_repo_dir)
    manager_repo_file.write(repo_text)
    manager_repo_file.flush()

    return manager_repo_dir, manager_repo_file

def _install_or_upgrade_packages():
    manager_repo_dir = None
    manager_repo_file = None
    try:
        manager_repo_dir, manager_repo_file = _create_manager_repo()
        log.info("{action} Intel(R) Manager for Lustre*".format(action="Upgrading" \
                                                                if upgrade \
                                                                else "Installing"))
        p = subprocess.Popen(["yum", "-y", "--enablerepo=chroma-manager",
                              "upgrade" if upgrade else "install",
                              MAIN_PACKAGE], stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT, bufsize=0)
        spinner(p)
    finally:
        if manager_repo_dir:
            shutil.rmtree(manager_repo_dir)
        if manager_repo_file:
            os.remove(manager_repo_file.name)

def _install_or_upgrade_bundles(old_bundles, new_bundles):
    for bundle, meta in new_bundles.items():
        install_location = os.path.join(BUNDLE_ROOT, meta['name'])
        if bundle in old_bundles:
            backup_location = os.path.join(BUNDLE_BACKUP,
                                           old_bundles[bundle]['name'])

            log.debug("Backing up %s to %s" % (install_location,
                                               backup_location))

            # Ensure the backup location exists
            _mkdir_p(BUNDLE_BACKUP)

            # Remove any old backups
            if os.path.exists(backup_location):
                log.debug("Removing old backup %s" % backup_location)
                shutil.rmtree(backup_location)

            # Move the installed bundle to backup location
            shutil.move(install_location, backup_location)

        # Extract the new bundle
        _mkdir_p(install_location)
        _unpack_repo(meta['filename'], install_location)
        _run(['chroma-config', 'bundle', 'register', install_location])

def _install_or_upgrade_profiles(new_profiles):
    log.info("Registering profiles")

    for profile in new_profiles:
        _run(['chroma-config', 'profile', 'register', profile])

def _test_yum():

    log.info("Testing YUM")

    yb = yum.YumBase()
    yb.setCacheDir()

    failed_urls = []
    for repo in yb.repos.listEnabled():
        # set up a proxy handler if necessary
        if repo.proxy_dict:
            urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler(repo.proxy_dict)))

        if repo.mirrorlist:
            urls = [repo.mirrorlist]
        else: # baseurl[s]
            urls = [url + "/" + "repodata/repomd.xml" for url in repo.baseurl]

        failures = 0
        for url in urls:
            parse_result = urlparse(url)

            # if the url has a user-information component split it out and auth with it.
            # ex: https://username:password@example.com'
            if parse_result.username:
                l = list(parse_result)
                # replace netloc with hostname
                l[1] = parse_result.hostname

                url = urllib2.Request(urlunparse(tuple(l)))
                base64string = base64.encodestring(
                    '%s:%s' % (parse_result.username, parse_result.password)
                ).replace('\n', '')
                url.add_header("Authorization", "Basic %s" % base64string)

            try:
                urllib2.urlopen(url, timeout=5)
            except urllib2.URLError:
                failures += 1
                failed_urls.append(url)
            else:
                continue

        if failures == len(urls):
            log.debug("Failed to read information for repository %s." % repo.id)
            return False, failed_urls

    return True, []

log = _setup_logging()

_display_eula()

version, release = _get_version()

if version:
    upgrade = True
else:
    upgrade = False

log.info("Starting {PRODUCT_NAME} {action}".format(PRODUCT_NAME=PRODUCT_NAME,
                                                   action = "upgrade" \
                                                       if upgrade \
                                                       else "installation"))

yum_ok, urls = _test_yum()
if not yum_ok:
    log.info("Yum does not seem to be able to find required network resources.  Please check your network and yum configuration and try again.  Perhaps you need ot disable some repositories that are not reachable.")
    log.info("URLs that failed: %s" % ' '.join(urls))
    sys.exit(1)

if upgrade:
    # Tell the user what the old version is
    _print_version(version=version, release=release)

    # Enumerate the old bundles (and soon, profiles)
    old_bundles = _old_bundles()

    _run(['chroma-config', 'stop'])
else:
    old_bundles = {}

# Find the new bundles and profiles
new_bundles = _new_bundles()
new_profiles = _new_profiles()

# Update RPMs
_install_or_upgrade_packages()

# Ensure database migrations are run (may prompt the user)
_run(['chroma-config', 'setup'], passthrough=True, drain_stdin=True)

# Install/update bundles
_install_or_upgrade_bundles(old_bundles, new_bundles)

# register (new) profiles
_install_or_upgrade_profiles(new_profiles)

# Tell the user what the (new) version is
_print_version()

log.info("\n{PRODUCT_NAME} {action} completed successfully\n".format(PRODUCT_NAME=PRODUCT_NAME,
                                                                     action="upgrade"
                                                                         if upgrade
                                                                         else "installation"))
